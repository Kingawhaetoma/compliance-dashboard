"use server";

import { revalidatePath } from "next/cache";

import { prisma } from "@/lib/prisma";

export type CreateAuditWorkflowInput = {
  customerOrgName: string;
  vendorOrgName: string;
  engagementName?: string | null;
  assessmentName?: string | null;
  frameworkIds: string[];
  startDate?: string | null; // YYYY-MM-DD
  dueDate?: string | null; // YYYY-MM-DD
};

function parseDateInput(value?: string | null) {
  if (!value) return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const parsed = new Date(`${trimmed}T00:00:00`);
  if (Number.isNaN(parsed.getTime())) {
    throw new Error(`Invalid date: ${trimmed}`);
  }
  return parsed;
}

function compactName(value: string) {
  return value.trim().replace(/\s+/g, " ");
}

function todayDateString() {
  return new Date().toISOString().slice(0, 10);
}

export async function createAuditWorkflow(input: CreateAuditWorkflowInput) {
  const customerOrgName = compactName(input.customerOrgName || "");
  const vendorOrgName = compactName(input.vendorOrgName || "");
  const frameworkIds = [...new Set((input.frameworkIds ?? []).filter(Boolean))];
  const startDate = parseDateInput(input.startDate ?? todayDateString());
  const dueDate = parseDateInput(input.dueDate ?? null);

  if (!customerOrgName) throw new Error("Customer organization is required");
  if (!vendorOrgName) throw new Error("Vendor organization is required");
  if (frameworkIds.length === 0) throw new Error("Select at least one framework");
  if (!startDate) throw new Error("Start date is required");
  if (dueDate && dueDate < startDate) throw new Error("Due date cannot be before start date");

  const result = await prisma.$transaction(async (tx) => {
    const customerOrg = await tx.organization.upsert({
      where: { name: customerOrgName },
      update: {},
      create: { name: customerOrgName },
    });

    const vendorOrg = await tx.organization.upsert({
      where: { name: vendorOrgName },
      update: {},
      create: { name: vendorOrgName },
    });

    const selectedFrameworks = await tx.framework.findMany({
      where: { id: { in: frameworkIds } },
      select: { id: true, key: true, name: true, version: true },
      orderBy: { key: "asc" },
    });

    if (selectedFrameworks.length !== frameworkIds.length) {
      throw new Error("One or more selected frameworks could not be found");
    }

    const controls = await tx.control.findMany({
      where: { frameworkId: { in: frameworkIds } },
      select: { id: true },
      orderBy: [{ frameworkId: "asc" }, { code: "asc" }],
    });

    if (controls.length === 0) {
      throw new Error("No controls found for selected framework(s)");
    }

    const engagementName =
      compactName(input.engagementName ?? "") ||
      `${customerOrgName} - ${vendorOrgName} Compliance Program`;

    const engagement = await tx.engagement.upsert({
      where: {
        customerOrgId_vendorOrgId_name: {
          customerOrgId: customerOrg.id,
          vendorOrgId: vendorOrg.id,
          name: engagementName,
        },
      },
      update: {
        status: "ACTIVE",
        startDate,
        dueDate,
      },
      create: {
        customerOrgId: customerOrg.id,
        vendorOrgId: vendorOrg.id,
        name: engagementName,
        status: "ACTIVE",
        startDate,
        dueDate,
      },
    });

    const frameworkLabel = selectedFrameworks.map((f) => f.key).join(" + ");
    const generatedAssessmentName =
      compactName(input.assessmentName ?? "") ||
      `${vendorOrgName} ${frameworkLabel} Audit ${todayDateString()}`;

    const assessment = await tx.assessment.create({
      data: {
        organizationId: vendorOrg.id,
        engagementId: engagement.id,
        name: generatedAssessmentName,
        status: "IN_PROGRESS",
        startDate,
        endDate: dueDate,
      },
    });

    await tx.controlResponse.createMany({
      data: controls.map((control) => ({
        assessmentId: assessment.id,
        controlId: control.id,
        status: "NOT_IMPLEMENTED",
        reviewStatus: "DRAFT",
        dueDate,
      })),
    });

    // Keep legacy findings in sync so existing assessment/detail pages continue to work.
    await tx.finding.createMany({
      data: controls.map((control) => ({
        assessmentId: assessment.id,
        controlId: control.id,
        status: "NOT_IMPLEMENTED",
        dueDate,
        notes: "Generated by audit workflow wizard. Update status and upload evidence to begin review.",
      })),
    });

    return {
      assessmentId: assessment.id,
      engagementId: engagement.id,
      customerOrgName: customerOrg.name,
      vendorOrgName: vendorOrg.name,
      assessmentName: assessment.name,
      engagementName: engagement.name,
      frameworks: selectedFrameworks,
      generatedControlCount: controls.length,
    };
  });

  revalidatePath("/assessments");
  revalidatePath("/customer");
  revalidatePath("/vendor");
  revalidatePath("/dashboard");
  revalidatePath("/controls");

  return result;
}

